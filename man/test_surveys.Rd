% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/test_surveys.R
\name{test_surveys}
\alias{test_surveys}
\alias{resume_test}
\title{Test sampling design of multiple surveys using a stratified analysis}
\usage{
test_surveys(sim, surveys = expand_surveys(), keep_details = 1,
  n_sims = 1, n_loops = 100, cores = 2, export_dir = NULL, ...)

resume_test(export_dir = NULL)
}
\arguments{
\item{sim}{Simulation from \code{\link{sim_distribution}}.}

\item{surveys}{A data.frame or data.table with a sequence of surveys and their settings
with a format like the data.table returned by \code{\link{expand_surveys}}.}

\item{keep_details}{Survey and stratified analysis details are dropped here to minimize object
size. This argument allows the user to keep the details of one
survey by specifying the survey number in the data.frame supplied to \code{surveys}.}

\item{n_sims}{Number of times to simulate a survey over the simulated population.
Requesting a large number of simulations here may max out your RAM.}

\item{n_loops}{Number of times to run the \code{\link{sim_survey}} function. Total
simulations run will be the product of \code{n_sims} and \code{n_loops}
arguments. Low numbers of \code{n_sims} and high numbers of \code{n_loops}
will be easier on RAM, but may be slower.}

\item{cores}{Number of cores to use in parallel. More cores should speed up the process.}

\item{export_dir}{Directory for exporting results as they are generated. Main use of the export
is to allow this process to pick up where \code{test_survey} left off by
calling \code{resume_test}. If NULL, nothing is exported.}

\item{...}{Arguments passed on to \code{sim_survey}
\describe{
  \item{sim}{Simulation from \code{\link{sim_distribution}}}
  \item{n_sims}{Number of surveys to simulate over the simulated population. Note: requesting
a large number of simulations may max out your RAM. Use
\code{\link{sim_survey_parallel}} if many simulations are required.}
  \item{q}{Closure, such as \code{\link{sim_logistic}}, for simulating catchability at age
(returned values must be between 0 and 1)}
  \item{trawl_dim}{Trawl width and distance (same units as grid)}
  \item{resample_cells}{Allow resampling of sampling units (grid cells)? Setting to TRUE may introduce bias
because depletion is imposed at the cell level.}
  \item{binom_error}{Impose binomial error? Setting to FALSE may introduce bias in stratified estimates
at older ages because of more frequent rounding to zero.}
  \item{min_sets}{Minimum number of sets per strat}
  \item{set_den}{Set density (number of sets per [grid unit] squared). WARNING:
may return an error if \code{set_den} is high and
\code{resample_cells = FALSE} because the number of sets allocated may
exceed the number of cells in a strata.}
  \item{lengths_cap}{Maximum number of lengths measured per set}
  \item{ages_cap}{If \code{age_sampling = "stratified"}, this cap represents the maximum
number of ages to sample per length group (defined using the \code{age_length_group}
argument) per division or strat (defined using the \code{age_space_group} argument)
per year. If \code{age_sampling = "random"}, it is the maximum number of ages to sample
from measured fish per set.}
  \item{age_sampling}{Should age sampling be "stratified" (default) or "random"?}
  \item{age_length_group}{Numeric value indicating the size of the length bins for stratified
age sampling. Ignored if \code{age_sampling = "random"}.}
  \item{age_space_group}{Should age sampling occur at the "division" (default) or "strat" spatial scale?
That is, age sampling can be spread across each "division" or "strat"
in each year to a maximum number within each length bin (cap is defined using
the \code{age_cap} argument). Ignored if \code{age_sampling = "random"}.}
  \item{light}{Drop some objects from the output to keep object size low?}
}}
}
\value{
Adds a table of survey designs tested. Also adds details and summary
        stats of stratified estimate error to the \code{sim} list, ending with
        \code{"_strat_error"} or \code{"_strat_error_stats"}. Error statistics
        includes mean absolute error (\code{"MAE"}), mean squared error (\code{"MSE"}),
        and root mean squared error (\code{"RMSE"}). Also adds a sample size summary table
        (\code{"samp_totals"}) to the list. Survey and stratified analysis
        details are not kept to minimize object size.
}
\description{
This function allows a series of sampling design settings to
be set and tested on the simulated population. True population values are compared
to stratified estimates of abundance.
}
\details{
Depening on the settings, \code{test_surveys} may take a long time to run.
The \code{resume_test} function is for resuming partial runs of \code{test_surveys}.
Note that progress bar time estimates will be biased here by previous completions.
\code{test_loop} is a helper function used in both \code{test_surveys} and
\code{resume_test}.
}
\examples{

\dontrun{
pop <- sim_abundance(ages = 1:20, years = 1:5) \%>\%
           sim_distribution(grid = make_grid(res = c(10, 10)))

surveys <- expand_surveys(set_den = c(1, 2) / 1000,
                          lengths_cap = c(100, 500),
                          ages_cap = c(5, 20))

## This call runs 500 simulations of 8 different surveys over the same
## population, and then runs a stratified analysis and compares true vs
## estimated values. It may take a while to run.
tests <- test_surveys(pop, surveys = surveys, keep_details = 1,
                      n_sims = 10, n_loops = 50, cores = 2)

library(plotly)
tests$total_strat_error \%>\%
    filter(survey == 8, sim \%in\% 1:50) \%>\%
    group_by(sim) \%>\%
    plot_ly(x = ~year) \%>\%
    add_lines(y = ~I_hat, alpha = 0.5, name = "estimated") \%>\%
    add_lines(y = ~I, color = I("black"), name = "true") \%>\%
    layout(xaxis = list(title = "Year"),
           yaxis = list(title = "Abundance index"))

plot_total_strat_fan(tests, surveys = 1:8)
plot_length_strat_fan(tests, surveys = 1:8)
plot_age_strat_fan(tests, surveys = 1:8)
plot_age_strat_fan(tests, surveys = 1:8, select_by = "age")

plot_error_surface(tests, plot_by = "rule")
plot_error_surface(tests, plot_by = "samples")

plot_survey_rank(tests, which_strat = "length")
plot_survey_rank(tests, which_strat = "age")

}

}
